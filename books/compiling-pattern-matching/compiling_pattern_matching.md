---
title: パターンマッチのコンパイル作戦会議
---

ここまでで、前提となる知識や条件、そしてどんなことをするのかを確認してきました。ここから本題となるパターンマッチのコパイルアルゴリズムを見ていきます。

はじめに、以降のコードは以下に置いてあります。

https://github.com/KeenS/pattern-match-compile

コード全体が欲しい方や動かしたい方はこちらを参照下さい。


まずは肩慣らしも兼ねてシンプルなパターンからC風言語へのコンパイルアルゴリズムをみます。これは先程確認したように、ほぼ直接的な変換ですので難しいところはないでしょう。アルゴリズムというよりはむしろ、データ型やコンパイラのコードの雰囲気を掴むために見ていきます。

次に複雑なパターンからシンプルなパターンマッチのネストへのコンパイルを見ていきます。これはアルゴリズムが2通りあるのでそれぞれ見ます。

片方のアルゴリズムは本記事では「バックトラック法」と呼ぶことにします。これは「`switch` が使えるところでは使う」といった趣で、愚直な `if` 文のネストを高速化したような結果になります。`if` 文のネストの場合と同じくパターンの並べ方と対象のデータに応じてパターンマッチにかかる時間が変わりますが、生成されるコード量は `if` のネストの場合と同じく書いたパターンに比例した分にしかなりません。

もう片方のアルゴリズムは本記事では「決定木法」と呼ぶことにします。全ての場合を尽すように `switch` をネストさせるもので、パターンの並びに関わらずデータ型の複雑さに比例した時間だけでパターンマッチを行えます。これは前半の記事で3行のコードが膨大な量のコードになる例で確認したとおり、元のコードよりも爆発的にコード量が増える可能性があります。

これら2つのアルゴリズムは時間と空間のトレードオフがあるのでそれを理解した上でどちらかを選択することになるでしょう。

さて、今まで出てきたコードと状況を整理しましょう。11章で `case` 言語とそのインタプリタを作成しました。我々の設計では `case` 言語からシンプルなパターンを持つ言語に変換し、さらにそこからC風の言語に変換するのでした。それぞれの言語を `simple_case` 言語と `switch` 言語、それぞれの間の変換を `CaseToSimple` コンパイラと `SimpleToSwitch` コンパイラ呼ぶことにすると、構成は以下のようになります。

```
case言語 ⟲ インタプリタ
 ↓ CaseToSimpleコンパイラ
 ↓    * バックトラック法
 ↓    * 決定木法
simple_case言語
 ↓ SimpleToSwitchコンパイラ
switch言語
```

このうち、`case` 言語とそとインタプリタのみ作成済みです。これから、 `simple_case` 言語、 `switch` 言語、そして `CaseToSwitch` コンパイラと `SimpleToSwitch` コンパイラを実装していきます。`CaseToSwitch` コンパイラは先程説明した通り、パターンマッチのコンパイルのアルゴリズムが複数あるのでそれらを切り替えられるようにします。


---
title: コンパイラの全景
---

ここで少し脇道に反れますが、コンパイラの行う処理とその中でのパターンマッチのコンパイルの立ち位置を確認しておきましょう。
少し長くなりますので基本的なことをご存知の方は以下の点を確認して次の節に進んで構いません。

* コンパイラの内部ではいくつかの中間言語、いくつもの処理に分かれる
* パターンマッチのコンパイルの前に名前解決、型推論、脱糖が終わっているものとする
* パターンマッチを2段階に分けて処理する
  1. ネストしたパターンをシンプルなパターンマッチのネストに置き換える
  2. シンプルなパターンマッチをC風のswitch文にコンパイルする
* 前者は高級中間言語内で、後者は高級中間言語から低級中間言語へのコンパイル時に行うとする



（作図）
``` text
テキスト
↓ パース
AST
↓ 脱糖とか型推論とか
高級中間言語
↓ loweringなどと呼ばれる
低級中間言語
↓ コード生成
機械語
```

コンパイラは人間が書いたテキスト、文字の列を受け取って機械語を生成する変換器です。
C言語のように機械に近い機能しか持たない言語だと1 passでコンパイラが書けたりしますが、SMLのような高級言語だとそうはいきません。
途中いくつもの中間データ構造（言語）を経て少しずつ高級な機能を解きほぐしながら機械語へと下っていきます。
幾段ものステップを辿りながら目的のコードを吐き出す様はまさにヤクの毛刈りの例えがピタリと当て嵌ります。
例えば今回用いているSML処理系のSML#は20以上の中間言語を下りながらコンパイルしています。

中間に設けられる言語はコンパイラの設計次第ですが、以下のように分類できるものが多いようです。

* 抽象構文木: テキストの構造に対応したデータ型
* 高級中間言語: シンタックスシュガーなどを解決し、基本的な機能に絞った言語。元の言語のサブセットかそれに近しいもの
* 低級中間言語: C言語のように低級な機能しか持たない言語。 `goto` やメモリ操作がある。

コンパイラはまずテキストをデータ型にした抽象構文木を作ります。
これがコードをデータとして扱う出発点です。
抽象構文木の中でできる処理をしたあとは、より基本的な機能だけを残した高級中間言語に変換します。
高級中間言語は機能を絞りつつ、もとの言語に近しい形をしているので言語固有の処理や最適化に適します。
高級中間言語での処理に満足したら低級中間言語に変換します。
この言語はC言語のようにマシンに近い処理を記述できるのでメモリの扱いや制御フローなどの処理や最適化に適します。
この中間言語は最近だとLLVM IRなどがよく使われるでしょう。
古典的なコンパイラの教科書で扱われる部分でもあります。

今回の例でいくと、 `case` 言語と `simple_case` 言語が高級中間言語、 `switch` 言語が低級中間言語をイメージして設計しています。

まずパースした結果は抽象構文木と呼ばれる、テキストの構文に対応したデータ型になります。
抽象構文木内で脱糖、名前解決や型推論などをします。

## 脱糖

**脱糖** （desugar）は糖衣構文を剥がし、別の基本的な構文に変換する処理です。
これらは何度か繰り返して最終的に表層構文のサブセットの基本的な構文の言語に落とされます。
SMLの真偽値の論理積構文、 `andalso` を例にとってみましょう。

``` sml
e1 andalso e2
```

`andalso` は `if` 式へと脱糖されます。

``` sml
if e1
then e2
else false
```

さらに `if` 式は `case` 式へと変換されます。

``` sml
case e1 of
  true => e2
| false => false
```

関数定義の `fun` 文も脱糖されます。
以下の引数でのパターンマッチをする関数定義を見てみましょう。

``` sml
(* logical and *)
fun land true true = true
  | land _    _    = false
```

引数でのパターンマッチをする関数は `case` 式へと脱糖されます。

``` sml
fun land x y = case (x, y) of
                 (true, true) => true
               | (_   , _)    => false
```

ここからさらにいくつかの脱糖があるのですが、ここでは割愛します。
特に、 `case` 式はSMLではさらに `fn` 式へと変換されるのですが、 `fn` 式が入るとパターンマッチとは関係ない所でコンパイルが難しくなるので
本記事では `case` までの脱糖で止めます。

このように、脱糖によって *分岐の制御構造が全て `case` 式になる* ことに注目して下さい。
本記事では `case` 式でのパターンマッチしか扱いませんが、それは全て `case` 式に集約されるからです。

脱糖は型推論や名前解決とは独立なので型推論の前に行われるとは限りません。パースする段階で脱糖してしまい、抽象構文木には残さないことも可能でしょう。

## 名前解決

**名前解決** （name resolution）は、名前空間に関する処理です。大抵の言語には名前空間（name space）がありますし、シャドイング（shadowing）もあります。
以下の例を見てみましょう。

``` sml
val x = 1
val y = let val x = 2 in x * x end
val z = x * x
```

1行目：トップレベルで `x` を1に束縛しています。
2行目：次にローカルで `x` を2に束縛し、 `x * x` を計算しています。その結果に `y` を束縛しています。
3行目：最後に特にローカルの束縛は導入せずに `x * x` を計算しています。その結果に `z` を束縛しています。
`y` には4、 `z` には1が束縛されてるのが簡単に分かるかと思います。

TODO: 説明がくどい気がする
しかし、同じ `x * x` という式なのに結果が異なるのはよく考えてみると奇妙ですね。
少なくともコンピュータにとっては扱いずらい性質です。
どうして人間が `y` の `x * x` と `Z` の `x * x` が違う結果になると分かるかというと、ぞれぞれで参照している `x` が別物だと理解できるからです。
この見た目が同じだけど別物であるものを区別するのが名前解決です。
`y` の `x * x` は ローカルの `x` 、 `z` の `x` はトップレベルの `x` を指していると解決します。

解決された名前を分かりやすくする方法の1つとして、変数名に番号を振るというのがあります。
同じ変数には同じ番号を、見た目が同じでも違う変数には違う番号を振ります。
先程の例ですと以下のようになります。

編: 添字にできると嬉しい
``` sml
val x_1 = 1
val y_2 = let val x_3 = 2 in x_3 * x_3 end
val z_4 = x_1 * x_1
```

実装上はシンボルそのものをを番号にしてしまうという方法もありますが、説明の上では元の形を残したこの記法が分かりやすいでしょうから以後この記法を採用します。

名前解決を済ませるとどこでどの変数が使用されているかが簡単に分かるようになり、後段の処理がやりやすくなります。
また、モジュールなどの名前空間の機能が潰せます。

ここで名前に関連する重要な機能として、コンパイラ内部で使う変数の導入があります。

コンパイラ内部での変数の導入について、例を交じえて解説します。
以下のコードを考えます。

``` sml
val tmp = 4 div 5
val sum = 1 + 2 + 3
sum - tmp
```

変数 `tmp` と `sum` が使われています。

`sum` は複数の式の合成なのでコンパイラは内部で単純な式におきかえます。
このとき一時変数 `tmp` を作ります。

``` sml
val tmp = 4 div 5
(* 一時変数tmpが導入された *)
val tmp = 2 + 3
val sum = 1 + tmp
sum - tmp
```

元のコードになかった変数が導入されました。
しかし元からあった `tmp` と新しくコンパイラが導入した `tmp` が衝突して元のコードから結果が変わってしまいます。
そこでコンパイラ内部で生成された変数にはいままで存在しなかった番号を振ることでこのような問題を避けられます。

``` sml
val tmp_1 = 4 div_2 5
(* 一時変数tmp_4が導入された *)
val tmp_4 = 2 + 3
val sum_3 = 1 + tmp_4
sum_3 - tmp_1
```

このように既存の変数と衝突しない変数を作り出す機能が必要です。
変数名は **シンボル** （symbol）とも呼ばれるのでシンボル生成処理を `gensym` と呼ぶことにします。
また、 `gensym` をする生成器を **シンボル生成器** （symbol generator）と呼びます。

<!--
case (1, 2) of (x, x) => ... はエラーになる話
case (1, 2) of (_, _) => ... はエラーにならない話

やりたいけどちょっとくどいので割愛。そこらへんあいまいにしておく
-->

## 型推論

**型推論** （type inference）は、式の型を自動で推論してくれる処理です。
例えば以下の関数を考えてみましょう。

``` sml
fun fact n = if n = 0
             then 1
             else n * fact (n - 1)
```

これはまず名前解決されます。


``` sml
fun fact_1 n_2 = if n_2 =_3 0
             then 1
             else n_2 *_4 fact_1 (n_2 -_5 1)
```

この状態で型推論をします。
コードには型が一切書かれていないにもかかわらず、コンパイラはどの変数がどの型かを推論できます。

```
fact_1: int -> int
n_2   : int
=_3   : int * int -> bool
0     : int
1     : int
*_4   : int * int -> int
-_5   : int * int -> int
```

型推論については本記事の主題ではないので専門書を当って下さい。

ここでは全ての式についてコンパイラが自動で付与した型がついていることを押さえておいて下さい。


## Lowering

さて、ASTでの処理が終わったらさらに基本的な機能しか持たない高級中間言語に落とし込みます。
この呼び方は色々あるようですが、ここではLoweringと呼んでおきます。

Loweringでは例えば、 `val` でのパターンマッチを `case` 式を使って分解します。
以下のコードを考えます。

``` sml
val Foo(x, y) = foo
```

この文は `case` を使って3つの文に分解できます。


``` sml
val tmp = case foo of Foo(x, y) => (x, y)
val x = case tmp of (x, _) => x
val y = case tmp of (_, y) => y
```

この言語自体にはデータ型の定義（`datatype name = ...`）はありません。
コンパイラの内部で型IDとその定義の対応表を持っているのみで、言語には表れないのです。

また、ASTから高級中間言語に落とす際に先程の型推論で取り出した型情報を捨ててしまうこともあります。
コンパイルに必要ないのであれば型が合っていることだけ確認して型情報を捨てる設計も十分ありえます。
今回の `case` 言語ではコンパイルに最低限必要な `case` 式の条件部分にのみ型を保持しています。


### 高級中間言語でのパターンのコンパイル

パターンマッチのコンパイルの1段階目はここで行ないます。
パターンマッチに関連する機能が全て `case` に集約されたところでネストしたパターンをネストしてないパターンマッチのネストに変換するのです。
この1段階目のコンパイルのときに網羅性が検査されます。
その結果、この `Foo` によるマッチが網羅的でないと判断されたらデフォルト節が用意され、 `Foo` にマッチしなかったら例外を送出するコードに変換されます。

``` sml
val tmp = case foo of
            Foo(x, y) => (x, y)
          | _ => raise Bind
val x = case tmp of (x, _) => x
val y = case tmp of (_, y) => y
```


パターンマッチの変換では `case` 式を複数の単純な `case` 式に置き換えるので式が増えます。

どうしてパターンマッチのコンパイルを2段に分けているかというと、その間に他の処理を挟みたいからです。
1段目のパターンマッチのコンパイルで式が増えるので、それを処理する必要があります。
例えば不要式の除去やクロージャ変換などさまざまな処理が入るでしょう。

## Loweringその2

高級中間言語での処理を終えたあとは低級中間言語にコンパイルします。
低級中間言語は主に **制御フローグラフ** （Control Flow Graph）と呼ばれるものになります。
この低級中間言語に変換するときに代数的データ型はタグ付き共用体に翻案し、 `case` 式は `switch` 文に変換します。
メモリ操作やや制御構造が陽に扱えるのが特徴です。設計次第ですが、恐らく `goto` も使うことになるでしょう。
例えば、先程の `Foo` のパターンマッチをする `val` 文は以下のようにC風の言語にコンパイルされるかもしれません。

``` c
struct sml_tuple2 *tmp;
int x, y;

switch(foo->descriminant) {
  case FOO: {
    tmp = sml_malloc(sizeof(struct sml_tuple2));
    tmp->fst = foo->data->fst;
    tmp->snd = foo->data->snd;
    break;
  }
  default: {
    sml_raise(SML_EXN_BIND);
  }
}

x = tuple2->fst;
y = tuple2->snd;
```

このあとメモリ操作や制御フローの最適化が入り、もしかしたら以下のように最適化されるかもしれません。

``` c
int x, y;

switch(foo->descriminant) {
  case FOO: {
    x = foo->data->fst;
    y = foo->data->snd;
    break;
  }
  default: {
    sml_raise(SML_EXN_BIND);
  }
}
```

この最適化のためには `sml_malloc` を除去していいことや、 `sml_raise` が制御を返さないという知識が必要です。
一般のCのコンパイラにはできないので何かしらの工夫が必要です。
LLVMなどの既存の中間言語を使うならコンパイラの持っている知識をその言語に伝えるようにしないとならないでしょう。

---

本節ではコンパイラの全景とその中でのパターンマッチのコンパイルの立ち位置を確認しました。
本記事で扱うコンパイラでは名前解決や脱糖、型推論が済んだあとの状態でパターンマッチの変換が行われます。
また、パターンマッチの機能は `case` 式に集約されるので `case` 式のみを扱えばいいことも確認しました。

パターンマッチのコンパイルがネストしたパターンの分解と、ネストしていないパターンから `switch` 文への変換に分けることも確認しました。
高級中間言語内で変換するには `switch` やメモリ操作などが足りませんし、高級中間言語→低級中間言語の変換時に一緒に変換すると途中で生じた余計な式を消しづらくなります。
また、採用するアルゴリズム次第ですがクロージャが増えることがあるのでクロージャ変換や必要になり、一緒に変換はできないこともあります。
ヤクの毛刈りのように1つの機能を解決したと思ったらまた別の機能が必要になって、と何度も変換を掛けながら目的のコードに向かっていきます。
本記事で示すアルゴリズムもそのような変換のうちの1つということを理解しておいて下さい。

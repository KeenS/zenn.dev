---
title: "基本文法"
---

本章ではIdrisの基本文法を学びます。


# コメント
## 1行コメント

`--` ではじめます。

例：

``` idris
-- これはコメントです
```

## 複数行コメント

`{-` から `-}`

例：

``` idris
{-
複数行で
コメントが
書けます
-}
```


### ドキュメントコメント

`|||` ではじまる1行コメントです。
詳しくは別の章で紹介します。

# 関数と変数

ドキュメントには書かれてないのですが、コンパイラのコードを見る限り識別子に使えるのは `[[:alphabet:]_][[:alphanum:]'_.]*` のようです。ここで `[:alphabet:]` に入るのはunicodeで[alphabetic](https://www.unicode.org/reports/tr44/#alphabetic)なもので、`[:alphanumeric:]` は alphabetic + numeric全般のようです。例えば `hog'.'e12_` や `漢字の識別子１` は適格なidrisの変数です。

## グローバル変数

変数は以下の構文で定義します。

``` idris
名前 : 型
名前 = 式
```

例：数値100を指すグローバル変数 `version` の定義

```idris
version : integer
version = 100
```

## 関数

関数は以下の構文で定義します。

``` idris
名前 : 型
名前 引数1 引数2 .. 引数n = 式
```

関数の型は `引数1の型 -> 引数2の型 -> 引数2の型 -> 返り型` です。

例：2つの `integer` である `x` と `y` を受け取り、 `integer` であるその和を返す関数 `add` の定義

```idris
add : integer -> integer -> integer
add x y = x + y
```

haskell風の文法ではセミコロンや括弧、カンマなどはあまり使いません。はじめは気持ち悪いかもしれませんが、じきに慣れてこっちの方が読みやすいと感じるようになります。

変数や関数はcamelcaseの命名が慣例です。コンパイラ側でも先頭に小文字がきたら変数と思って処理している箇所があるようですので、特別な理由がない限りは小文字始まりの変数名を使うとよいでしょう。

## ローカル変数

`let 変数 = 式 in 続く式` の構文で定義します。

例： `x` と `y` の和にローカル変数 `tmp` を束縛したあと `tmp` と `z` の和を計算するコード

``` idris
add3 : integer -> integer -> integer -> integer
add3 x y z = let tmp = x + y in
             tmp + z
```

他にも式の後ろに `where` を続けて書く記法もあります。

例： `where` を使って `x` と `y` の和にローカル変数 `tmp` を束縛したあと `tmp` と `z` の和を計算するコード


``` idris
add3 : integer -> integer -> integer -> integer
add3 x y z = tmp + z
where
  tmp : integer
  tmp = x + y
```

idrisは [オフサイドルール](https://ja.wikipedia.org/wiki/オフサイドルール)を採用しているのでインデントが同じなら同じブロックとみなしてくれます。
そのため `where` のあとに続く定義はインデントを揃えれば複数書けます。


## ローカル関数

`where` の記法で定義できます。

例： `where` を使って3つのローカル関数 `ism4` 、 `ism100` 、 `ism400` を定義し、それらでうるう年を判定するコード

``` idris
isleapyear : integer -> bool
isleapyear y = ism4 y && not (ism100 y) && ism400 y
where
  ism4 : integer -> bool
  ism4 y = y `mod` 4 == 0

  ism100 : integer -> bool
  ism100 y = y `mod` 100 == 0

  ism400 : integer -> bool
  ism400 y = y `mod` 400 == 0
```

ここで使った `&&` は論理積演算子、 `not` は論理否定の関数、 `` `mod` `` は剰余演算子、 `==` は等価演算子です。

## 無名関数

`\引数 => 式` の構文で作れます。

例： `double` を値を2倍にする無名関数に束縛し、それを2回適用することで値を4倍にするコード

``` idris
quatro: integer -> integer
quatro n = let double = \i => i * 2 in
           double (double n)
```

# 制御構造
## `if`

`if` 式は `if 条件 then then節 else else節` の構文をしています。

例：

``` idris
if n == 0
then "zero"
else "not zero"
```

idrisは式指向言語なので `if` も値を返します（なので `if` 「式」と呼ばれます）。他の言語でいういわゆる三項演算子のようなものは必要ありません。

例： `if` が式であることを使って `if` の返り値をそのまま別の関数に渡すコード

``` idris
main : io ()
main =
  putstrln (if 1 == 0 then "zero" else "not zero")
```

## パターンマッチ

パターンマッチは `case 条件 of パターン => 式 ...` の構文をしています。
`パターン => 式` の部分にはオフサイドルールが適用されます。


例：

``` idris
case n of
  1 => "one"
  2 => "two"
  3 => "three"
  _ => "many"
```

最後の `_` は特殊なパターンで、どんな値にもマッチしてその値を無視します。

パターンマッチはもうちょっと複雑なこともできます。値の構造がパターンに合致すればマッチ成功となります。さらに、その値を変数に束縛できます。

例：リストに対してパターンマッチし、分配束縛するコード。

``` idris
case list of
  [] => 0
  [x, y] => x + y
  [x, y, z] => x + y + z
  _ => -1
```

このコードに登場する `list` が `[1, 2, 3]` に束縛されているならば `[x, y, z]` の節にマッチして `x + y + z` 、つまり `1 + 2 + 3` が計算されて6が返ります。

### 関数の引数でのパターンマッチ

関数の引数でもパターンマッチが可能です。関数の名前を連ねる形になります。

例：$n$ 番目の[フィボナッチ数](https://ja.wikipedia.org/wiki/フィボナッチ数)を計算するコード

``` idris
fib: integer -> integer
fib 0 = 1
fib 1 = 1
fib n = fib (n - 1) + fib (n - 2)
```


## ループ、 `return` 、 `break`
ないよ。

idrisは関数型言語なのでループは関数を使います。自身を呼び出すことでループを作れるのです（再帰関数）。`break` や `return` は必要ありません。自身を呼び出すことをやめれば自然とループが止まりますし、その場で値が返ります。

例： `1` から `n` までの和を求める関数

``` idris
sumfromone: integer -> integer
sumfromone n = loop 1 n 0
where
  loop: integer -> integer -> integer -> integer
  loop i end sum =
    let sum = sum + i in
    if i == end
    then sum
    else loop (i + 1) end sum
```

関数 `sumfromone` の定義でローカル関数として `loop` を定義しています。この関数を再帰呼び出しすることでループを実現します。 `loop i end sum = ...` ではじまって `loop (i + 1) end sum` を呼んでいるので `i` を1つづつ増やしていっているのが読み取れるでしょうか。最初が `loop 1 n 0` なので `loop 2 n sum` 、 `loop 3 n sum` …と呼び出していって `loop n n sum` まできたところでループが終了します。

# 演算子

idrisには組み込みの演算子がありません。もうちょっというと演算子というものはありません。代わりに、関数を中置記法で書けるようにする方法が2つあります。ユーザで中置演算子を自由に作れる訳ですね。今まで使ってきた `+` なんかもこれに該当します。

2つの方法のうち1つ目の方法が `` ` `` 〜 `` ` `` で関数を囲むもの。

例： 2引数関数 `add` を `` ` `` 〜 `` ` `` で囲んで中置演算子として使うコード

``` idris
add : integer -> integer -> integer
add x y = x + y

1 `add` 2
```

逆に、中置演算子は `()` で囲って普通の関数のように使うこともできます。

``` idris
(+) 1 2
```

2つ目の方法が `infix` 系の構文です。 `infix` 、 `infixl` 、 `infixr` があります。 `infixl 4 +,-` のように `infixl 優先順位 シンボル1, シンボル2..` と書きます。これらの構文でinfix宣言されたシンボルは中置演算子として使えます。

``` idris
infixl 4 -?
prefix 2 -!

(-?) : integer -> integer -> integer
(-?) x y = x - y

(-!) : integer -> integer
(-!) x = 0 - x


-! 1 -? 2 -? 3
-- これは -! ((-?) ((-?) 1 2) 3) と解釈されて4になる
```

`infix` 系の構文で中置演算子として宣言できるのは記号だけのシンボルに限ります。アルファベットを使った関数は `` ` `` 〜 `` ` `` の記法で中置することになります。

## セクション

中置演算子を部分適用したいことがたまにあります。例えば `1 +` と書いて1を足す関数ができてほしいですよね。実際、そういう使い方ができます。

``` idris
-- 1を足す関数(1+)を2に適用
(1+) 2
-- -> 3


-- 3で割った余りを返す関数(`mod` 3)を5に適用
-- (`mod` 3) 5
-- -> 2
```

覚えておくと便利な構文ですね。


# データ型

`data 名前 = 定義` の構文で定義します。定義のところには `ヴァリアント | ヴァリアント…` と書きます。ヴァリアントには `コンストラクタ 引数の型 …` と書きます。ヴァリアントは少なくとも1つ、コンストラクタの引数は0以上を書きます。

例：引数のないコンストラクタのヴァリアントを2つ持つデータ型

``` idris
data bool = true | false
```



例：引数の2つあるコンストラクタのヴァリアントを1つ持つデータ型

``` idris
data person = mkperson int string
```

引数ありのコンストラクタのヴァリアントを1つ持つデータ型は頻出パターンで、構造体のように使えます。そのときのコンストラクタが構造体のコンストラクタのようになります。こういうときは `mkhoge` と `mk` （makeの略）を前置するのが慣例です。

`|` で複数のコンストラクタを組み合わせるのと引数のあるコンストラクタを両方同時に使うこともできます。

例： 引数のあるコンストラクタや引数のないコンストラクタのヴァリアントのあるデータ型

``` idris
data fizzbuzz = f | b | fb | i integer
```


データ型は語ることが多いので章を新ためて説明しようと思います。

# hole（穴）

idrisの重要かつ初心者にとって役に立つ機能にhole（穴）があります。未完成のプログラムを作ることができるのです。実装が難しい部分をholeにしておくことで後で実装したり、処理系からholeについての情報を得たりできます。さらにはエディタサポートも受けられます。

 `?` に続いてシンボルを書くとholeとして扱われます。例えば以下のように書きます。

例：holeを使ったプログラム

``` idris
awesomefunction: string -> integer
awesomefunction s = ?hole
```

この `?hole` の部分がholeの記法で、 `hole` という名前のholeを作っています。さらにここから `hole` の方を処理系から取得することもできます。

例：`hole` の型を処理系から取得した際の出力

``` text
    s : string
---------------
 hole : integer
```

これは `hole` の部分を埋めるにあたって、 `string` 型である `s` という変数が利用できて、 `hole` は `integer` 型であることが要求される、ということを表しています。

holeは式の途中で置くことも可能です。例えば以下のように `awesomefunction` の引数を `arg` というholeにすることもできます。

例：式の途中にholeを置くコード

``` idris
awesomevalue : integer
awesomevalue =
  let tmp = awesomefunction ?arg
  in tmp + 2
```

先程と同様に `arg` の型を取得することができます。

例：`arg` の型を処理系から取得した際の出力

``` text
-------------
arg : string
```

こちらは引数がないので分数表記の上の方は空ですね。

触れてませんでしたがholeを使って書いたコードも後の関数から使うことができます。上の `awesomevalue` がそうですね。このコードを読み込むとコンパイラがholeについての情報を出すのでholeを埋め忘れる心配はありません。

例：holeのあるプログラムを読み込んだときの出力

``` text
holes: main.arg, main.hole
```

holeについてはまだまだ語るところがあるのですが構文の学習からは少し離れてしまうのでこのあたりにしておきましょう。

# モジュールと名前空間

モジュールに関しては章を改めて紹介するので本章では軽く説明します。

## モジュール

ファイルの先頭で `module <名前>` と宣言することでそのファイルのモジュール名を指定します。

例：モジュール `main` を宣言するコード
``` idris
module main
```

## インポート

`import ディレクトリ.ファイル名` とすることでファイルをインポートできます。 `import` は `module` と コードの間に書きます。

例： `hoge/fuga/piyo.idr` にあるコードをインポートするコード
``` text
import hoge.fuga.piyo
```

## 名前空間

`module` はファイル単位ですが、`namespace` でファイル内にサブ名前空間を作ることができます。

例：名前空間 `foo` を作るコード
``` text
namespace foo
  -- このブロックは `foo` 名前空間に入る
```

# 本章のまとめ

Idrisの基本文法を学びました。

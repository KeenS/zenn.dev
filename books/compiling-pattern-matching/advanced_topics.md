---
title: 発展的話題
---

ここまでで、パターンマッチのコンパイルの2つのアルゴリズムを紹介しました。
どちらのアルゴリズムも、非常に基本的な部分のみを紹介しました。今回紙面の都合で扱えなかった話題を以下に紹介します。

## パターンマッチの他の機能

### 網羅性と非冗長性の検査

前回の記事ではパターンマッチでは網羅性と非冗長性が有用であると紹介しました。
しかし、今回紹介したアルゴリズムではわずかに決定木法で網羅性が検査できるだけです。
そこでパターンマッチのコンパイラとは別に、網羅性や非冗長性の検査アルゴリズムが必要です。

実は非冗長性判定があれば網羅性判定もできるようになります。
パターン行列の末尾に `_ => ...` の行を加えて非冗長性を行い、冗長であると判断されたなら元のパターン行列は網羅的です。
逆に冗長と判断されないならば元のパターン行列は非網羅的です。

### ORパターンやパターンガードなど

前回パターンマッチの機能として紹介しましたが、 今回の紙面では扱いきれませんでした。
ORパターンについては参考文献に記載があるので興味のある方は調べてみて下さい。
パターンガードについては筆者の調査不足で参考文献を見付けられませんでした。

### 数値やVoidへのマッチ

数値やVoid（コンストラクタが1つも存在しないデータ型）のマッチの実装は特別な配慮が必要です。

上で紹介した網羅性や非冗長性の検査は整数値のように値が多くあるケースは非常に扱いづらいです。

また、浮動小数点数へのマッチはNaNなどの扱いを考えはじめると難儀するでしょう。

Voidへの対応はアルゴリズムの修正が必要です。
例えば決定木法ではパターンの列が1つも存在しない場合は空則により即エラーになってしまいます。

## パターンマッチのコンパイルの最適化

本記事で紹介したアルゴリズムは正しくコンパイルできることだけに集中していました。
コンパイル結果のコードを小さく、あるいは速くすることに目を向けると、いくつか工夫点があります。

### バックトラック法の最適化

以下のパターンマッチはバックトラック法では混合則で3分割されるのでした。

``` sml
case c of
    (Nil, _) => E1
  | (_, Nil) => E2
  | (Cons(_, _), Cons(_, _)) => E3
```

一方、2節目と3節目をいれかえた以下のコードは2分割しかされません。

``` sml
case c of
    (Nil, _) => E1
  | (Cons(_, _), Cons(_, _)) => E3
  | (_, Nil) => E2
```

2つのコードは挙動が全く同じである点にも注目して下さい。
同じ挙動のコードであっても節の順序でコンパイル結果が変わることがあるのです。

これを利用して、順番を入れ替えても挙動が変わらない節の組さえ発見できればよりよいコンパイル結果が得られる方に改変できます。

### 決定木法の最適化

決定木法の最適化では2つの方法を紹介します。
1つはコードの無駄を省く方法、もう1つは質の良い決定木を生成する方法です。

#### コードの無駄を省く

決定木法では混合則で変数パターンの列がコピーされます。

``` rust
fn default_patterns(...) -> ... {
    clause_with_heads
        // ...
        // ↓ ココでcloneを呼んでる！！
        .cloned()
        // ...

}
```

これは `pat => expr` の `pat` や `expr` が複数回コンパイルされることを意味しています。
さらにいえば、 `pat` の中に変数パターンがあれば再度コピーが走るのでねずみ算式に式がコピーされてしまいます。

特に、 パターンの腕の `expr` 大きな式を置けるので複数回コンパイルされるのは可能な限り避けたいです。
パターンの腕に大きな式がある実例は、例えば決定木法の`specialized_patterns` を見ると比較的大きな式があるのがみてとれます。

`expr` のコピーに関しては、簡単には関数にしてしまえばある程度問題を解決できます。
すなわち、

``` sml
case cond of
    pat1 => expr1
  | pat2 => expr2
  | ...
```

という `case` 式を以下のように変換するのです。


``` sml
let
  fun doExpr1 () = expr1
  fun doExpr2 () = expr2
in
  case cond of
      pat1 => doExpr1 ()
    | pat2 => doExpr2 ()
    | ...
end

```

もし `goto` がある中間言語を使っているのなら関数ではなく `goto` にする手もあります。

これは簡単な解決方法をもたらしてくれる一方で、 `pat => expr` の `pat` の部分がコピーされる問題は解決していません。
`pat => expr` の部分は何度コンパイルしても結果は一緒なので可能なら一度だけコンパイルして、以降はその結果を使い回したいです。
それっぽい言い方をすると、決定木の部分木どうしが **極大共有（maximal sharing）** するようにしたいです。
極大共有な木を生成する方法がいくつか考案されています。

編: なんか図があると説明が楽

#### 質の良い決定木を生成する

決定木法の混合則では一番最初にみつかった変数ではないパターン（キー）を用いていました。

``` rust
fn find_nonvar(&mut self, clauses: &[(Stack<case::Pattern>, simple_case::Expr)]) -> usize {
    // ベクトルをスタックの代用としているので先頭から探索するには rpositionを使う
    clauses[0].0.iter().rposition(|p| !p.is_variable()).unwrap()
}
```

`find_nonvar` で最初にみつかったものを採用する必然はなく、条件を満たすならどのキーをもってきても構いません。
そして、どのキーをもってくるかによって決定木の形が変わります。
なので、より「良い決定木」を生成できるキーを探してあげれば質の良いコンパイル結果が得られます。

ここで2つの問題が浮上します。

1つ目は「良い決定木」とは何かという問題です。
決定木の高さ（`switch` 文のネストの深さの最大値）でとるのか、ネストの深さの平均値でとるのか、あるいは全体のswitch文の数でとるのか、色々指標がありえます。
まずは自分にとって何が適切かを決める必要があります。

2つ目は計算時間です。
実は、最適なキーを探すのは簡単です。
「良い決定木」が何かさえ決めてしまえば、全てのキーで一度コンパイルしてみて、最も「良い決定木」を生成できたキーを採用すればいいのです。
しかしこれでは明らかに時間がかかってしまいます。
他に方法なないのでしょうか？
残念ながら、最適なキーを探すには全てのパターンを試してみるより他ないようです。

「最適な」結果を得るには全てのパターンを試さないといけませんが、「ほどほどに良い」結果ならばもう少し簡単に得られます。
ヒューリスティック、要は「こういう条件を見たすキーを選ぶと質がよくなりがち」という経験則を集めてくればいいのです。
ほどほどに良い決定木を生成するためのキーの選び方の戦略がさまざまにあります。

---
title: "IOモナド"
---


本章ではIdrisのプログラムを書くにあたって必須となるIOモナドについて学びます。

# IOモナド

いままで、まともにHollo Worldを解説してませんでしたね。それはIO操作もモナドで書かれているからです。

ということでモナドを知った今、改めてHello Worldをしてみましょう。 `putStrLn` は以下のような型をしています。

``` text
Idris> :t putStrLn
putStrLn : String -> IO ()
```

そしてIdrisは `main : IO ()` な値からプログラムの実行を始めます。何度か出てきたHello Worldを改めて見直しましょう。

例：IdrisでのHello World

``` idris:HelloWorld.idr
main : IO ()
main = putStrLn "Hello, World"
```

`main` を `IO` モナドの値に束縛しています。これを `Hello.idr` として保存し、以下のように実行します。

例：Hello Worldをコンパイル・実行するコマンド

``` shell-session
$ idris -o HelloWorld HelloWorld.idr
$ ./HelloWorld
Hello, World
```

`-o` オプションをつけて `idris` コマンドを起動するとREPLではなくコンパイラが起動し、 `-o` で指定したファイルへとコンパイル結果を出力します。

`IO` モナドを使ってもうちょっと複雑なことをしましょう。 `getLine: IO String` で標準入力から1行取得できます。これと `putStrLn` で入力をエコーバックするプログラムはこう書けます。

例： `getLine` と `putStrLn` を使ってユーザの入力を表示するプログラム

``` idris:Echo.idr
main : IO ()
main = getLine >>= \s => putStrLn ("Your input is " ++ s)
```

あるいは、 `do` 記法でこう書くこともできます。

例： `getLine` と `putStrLn` を使ってユーザの入力を表示するプログラムを `do` 記法で書いたもの

``` idris:Echo.idr
main : IO ()
main = do
  s <- getLine
  putStrLn ("Your input is " ++ s)
```

これを `Echo.idr` に保存し、コンパイル、実行すると以下のように動作します。

``` shell-session
$ idris -o Echo Echo.idr
$ ./Echo
echooooo
Your input is echooooo
```

IOモナドを使うことで出入力ができることが分かりました。

## ところでIOって何？

`IO` の型にちょっと違和感を覚えた方もいるんじゃないかと思います。 `main` の型は `IO ()` という値です。関数じゃありません。同じく `getLine` も `IO String` という値です。これだと書いたそばから実行されてしまわないでしょうか。まあ、動いてるからにはそうならないんのは分かるんですが、どういう仕組みなんでしょう。

実はIdrisのプログラムからは `IO` の値を実行することができません。 `getLine` と書いたからといって即座に標準入力から文字列を取り出したりしないのです。唯一 `main` に書いた `IO` の値のみが処理系側で実行されます。処理系側で実行されてはじめて標準入力から文字列を取り出すというアクションが行なわれます。 `IO` は実行される前のプログラムのようなものなのです。

`IO` を実行できるのは `main`の1箇所のみとなると、複数のIO処理をしたいときは `IO` の値を合成する必要があります。その仕組みに選ばれたのがモナドという訳です。`>>=` は別名 bind （結合）ですが、先程の `getLine` と `putStrLn` のように複数のIO処理を結合するのに使われているのです。

## 純粋関数型言語とIO

さて、 `main` でしか `IO` を実行できないとなると他の関数内でIO処理をしたい場合はどうすればいいのでしょう。

1つの答えは「そういう関数は設計が悪いから書くな」です。純粋関数型言語であるIdrisの基本方針として、IOや変数への破壊的代入などの計算以外の処理はよくないものとされています。関数を呼んだときに何が起こるか分からなくなるからです。なので関数内でIO処理を書きたくなったときはまずは「計算部分とIO部分に分離できないか」と考えてみましょう。

もう1つの答えは 「全て `IO` モナドの中で書く」です。 `IO` モナドをリレーのように `main` まで伝えればIOを実行できます。なので関数の中でIOをしたければ `IO` モナドの中で書くことにすれば実現できます。とはいえやっぱりIOの中でプログラムを書くのは面倒なので基本的には純粋な計算部分とIO部分に分けて、IO部分でだけ `IO` モナドを使うようになります。

じゃあデバッグプリントを関数の中に仕込みたかったらどうなるの、などの疑問はあるかもしれません。まあ、普通に `IO` を使ってそれを呼ぶ関数を全て `IO` モナドの中で書くように変更します。しかしちょっと面倒ですよね。一応そういった用途のためのバックドアの機構があるにはあります。後の章で紹介することにしましょう。


# 本章のまとめ

Idrisの重要なモナド `IO` について学びました。 `IO` まで辿りついたことでIdrisのプログラムを書けるようになりました。

まだまだIdrisの機能はいっぱいあるので気を緩ませずに次に進みましょう。

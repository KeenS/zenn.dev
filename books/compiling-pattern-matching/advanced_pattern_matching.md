---
title: 発展的なパターン
---

ここまでは、SMLのパターンマッチをC言語へとコンパイルする変換の例を見ながら、下記の事実を説明してきました。

* パターンマッチを含むcase式はswitch文にする
* ネストしたパターンはswitch文のネストで表現する
* if文ではなくswitch文を使うことには理由がある

これは、いわばパターンマッチのコンパイラを書くときの基本の機能です。
パターンマッチを導入しているほとんどの言語には、ほぼ同じ機能が備わっています。

さらに、多くの言語では、これらの基本の機能に加えて発展的な機能も用意されています。
以降では、それらのうちいくつかを紹介していきます。

## 無限パターン（数値パターン）

★ 「ラベル」という語をこの意味では使っていないはず。「マッチ対象の節に指定するパターン」と書くしかないか -kshikano

いままでの説明では、マッチ対象のラベルは有限個で、そのすべてが網羅されているか確認できることが前提になっていました。
しかし、すべてのラベルが網羅されているか確認できないようなパターンもあります。
数値パターンがその一例です。

数値のビット数を厳密に定めていない言語や、多倍長整数のある言語では、すべての数を列挙できません。
そうした言語では数値パターンの網羅性検査を特別扱いする必要があります。

仮にそうでなくても、数値は範囲が広いので、網羅性検査には時間がかかってしまいます。
そのため、あえて網羅性検査を行わないという設計もありうるでしょう。

コンパイルに際しても注意が必要です。以下の例を考えてみましょう。

``` sml
case x of
   1      => 〈expr1〉
|  32     => 〈expr2〉
|  1024   => 〈expr3〉
|  327678 => 〈expr4〉
|  _      => 〈expr5〉
```

これを素直にジャンプテーブルにしようと思うと、約32万個のエントリが必要になり、現実的ではありません。
こうしたケースでは何かしらの工夫が必要です。
たとえば、ジャンプテーブルでなく、if文による二分探索へとコンパイルする手法が考えられます。

```{#lst:jumptable .c caption="二分探索へとコンパイルする例"}
if (x <= 32) {
  if (x == 1)           〈expr1〉;
  else if(x == 32)      〈expr2〉;
  else                  〈expr5〉;
} else {
  if (x == 1024)        〈expr3〉;
  else if (x == 327678) 〈expr4〉;
  else                  〈expr5〉;
}
```

あるいは、値テーブルとジャンプテーブルを別々に作る方法も考えられます。
ジャンプテーブルはC言語では直接は表現できませんが、ラベルを配列に保存できるとしたら、以下のようなコードで実現できるでしょう[^jumptable]。

[^jumptable]: GCCやClangでは拡張機能を使うとラベルを値として保存できます。[-@lst:jumptable]はその機能の文法に則って書かれています。

```{#lst:jumptable .c caption="ジャンプ先のテーブルを保持する例"}
  void* jump_table[5] = {&&L_1, &&L_32, &&L_1024, &&L_327678, &&L_default};
  int value_table[4] = {1, 32, 1024, 327678};
  // 値と値テーブルからインデックスを引く
  int index = search_index(value_table, x);
  goto *jump_table[(index + 5) % 5];
 L_1:
  〈expr1〉;
 L_32:
  〈expr2〉;
 L_1024:
  〈expr3〉;
 L_327678:
  〈expr4〉;
 L_default:
  〈expr5〉;
```

もっとも、これらの使い分けについて考慮が必要になるのは、最終的にアセンブラを生成するときです。
C言語やそれに類似した中間言語がターゲットの場合には、あまり気にせずswitch文を使ってかまいません。
中間言語からアセンブラにするときに、switch文で使われているラベルを見て使い分ければいいからです。

## ORパターン

ORパターンは、1つの節にいくつかのパターンを並置できる機能です。
SMLの仕様にはない機能ですが、独自拡張として搭載している処理系があります。
たとえば、有名なSMLの処理系SML/NJ（Standard ML of New Jersey）はORパターンを実装しています。
ここではSML/NJ[^smlnjspec]のコード例と共にORパターンを見ていきます。

[^smlnjspec]: 本項の内容はStandard ML of New Jersey v110.79に基づくものです。

SMLでの `isWeekend'` 関数は以下のように定義されていました。

```{#lst:isweekend2-re .sml caption="week型に対するパターンマッチ2（再掲）"}
fun isWeekend' w = case w of
                      Sunday => true
                    | Saturday => true
                    | other => false
```

`Sunday` と `Saturday` は、どちらも同じく `true` になります。これらをまとめて扱うことはできないでしょうか。
SML/NJのORパターンを使うと、 `Sunday` と `Saturday` の2つのパターンを「`|`」の前後に並置できます。
ORパターンでは、「`|`」の前後のどちらかにマッチした場合に腕の式が実行されます。

```{#lst:isweekend2-or .sml caption="ORパターン"}
fun isWeekend w = case w of
    Sunday | Saturday => true
    | other => false
```

一般に、以下のORパターンは…

``` sml
(〈pattern1〉 | 〈pattern2〉) => 〈expr〉
```

\noindent 以下のように2つのパターンに分解して書いた場合と同等です。

``` sml
〈pattern1〉 => 〈expr〉
〈pattern2〉 => 〈expr〉
```

ただし、ORパターンを実装するうえでは、上記のようにナイーブに2つの節に分けるのはあまりうまくありません。
`〈expr〉` が複製されているので、場合によってはコードサイズが嵩んでしまうからです。
ORパターン1つくらいなら許容できるかもしれませんが、以下のようないじわるな入力を考えると…

``` sml
fun bloat tuple = case tuple of
     ((1|2), (3|4), (5|6)) => 〈expr1〉
    | other => 〈expr2〉
```

以下のように`〈expr1〉`が8倍に増えます。
ORパターンをナイーブに実装すると、一般には指数関数的にコードサイズが増えてしまう場合があるので、あまり得策ではありません。

```sml
fun bloat tuple = case tuple of
    (1, 3, 5) => <expr1>
  | (1, 3, 6) => <expr1>
  | (1, 4, 5) => <expr1>
  | (1, 4, 6) => <expr1>
  | (2, 3, 5) => <expr1>
  | (2, 3, 6) => <expr1>
  | (2, 4, 5) => <expr1>
  | (2, 4, 6) => <expr1>
  | other     => <expr2>
```

> note
> ORパターンの扱いは、実装だけでなく、パターンマッチの各種アルゴリズムを考慮する際にも検討が必要になります。詳しくは記事を改めて解説する予定です。

ところで、ORで並置したパターンのどちらにもマッチするケースもありえます。
多少人工的な例ですが、以下のパターンを考えてみましょう。

``` sml
fun matchList (_ :: x | x) = List.length x
```

`matchList [1, 2]` を評価すると、`_ :: x` と `x` どちらにもマッチします。
`_ :: x` にマッチしたとみなすと、 `x` は `[2]` に束縛されるので式の返り値は `1` になります。
一方、 `x` にマッチしたとみなすと、 `x` は `[1, 2]` に束縛されるので式の返り値は `2` になります。
どちらが正しい挙動でしょうか。

筆者の知る限り、ORパターンを実装している言語では、どれも左側のパターンを優先的にマッチさせるようです。
パターンを上から優先的にマッチさせるのと同様に、ORでも左を優先させるほうが直観的だからでしょう。
SML/NJのORパターンでも、左に書いたパターンが優先的にマッチします。

## パターンガード

パターンガードは、パターンでマッチしたあと、さらにユーザが書いたコードでマッチする条件を絞るという機能です。
パターンガードを実装している言語の例として、OCamlがあります。
以下ではOCaml[^ocamlspec]のコード例でパターンガードを見ていきます。

[^ocamlspec]: 本項の内容はOCaml 4.08.0に基づくものです。

[-@lst:issequence]の`isSequence`の定義を三たび再掲します。

```{#lst:issequence3 .sml caption="\ref{lst:issequence}の再掲"}
datatype stone = Black | White

datatype cell = Empty | Full of stone

fun isSequence s = case s of
                       (Full Black, Full Black, Full Black) => true
                    |  (Full White, Full White, Full White) => true
                    | _ => false
```

これをそのままOCamlに翻訳すると以下のようになります。
同じML語族の言語なので多少のキーワードの修正で翻訳できます。

``` ocaml
type stone = Black | White

type cell = Empty | Full of stone

let is_sequence s = match s with
    (Full Black, Full Black, Full Black)  -> true
  | (Full White, Full White, Full White)  -> true
  | _ -> false
```

このパターンマッチでは、3つの要素がすべて `Full` で、かつ石の色が3つとも同じであるパターンを確かめています。
そのために石の色ごとに3つの要素をすべて列挙して、 `(Full Black, Full Black, Full Black)` と `(Full White, Full White, Full White)` というパターンを書くのは、少し冗長で無駄に思えますね。

パターンガードを使うと、この例をもっとすっきり書けます。
OCamlでは、パターンのあとに `when 〈expr〉` と続けることで、マッチ対象を絞れます。

``` ocaml
let is_sequence s = match s with
    (Full x, Full y, Full z) when x = y && y = z -> true
  | _ -> false
```

これで1行短くなりました。

便利なパターンガードですが、利用にあたっては注意も必要です。
ガード式には任意の式が書けるので、コンパイラが振る舞いを判定できるとは限りません。
そのため、たとえば人間が見ると明らかに冗長な以下のようなパターンでも、コンパイラが警告を出してくれないのです。

``` ocaml
let is_black color = match color with
    (* ガードが付いているが、trueなので常にマッチする *)
    Black when true -> true
    (* なのでこの節は冗長 *)
  | Black -> true
  | White -> false
```

網羅性に関しても同じように注意が必要になります。以下の例は、2つの `Black` に付いているガード式が互いに背反するので、網羅的です。

``` ocaml
let is_black color = match color with
    Black when true -> true
    (* ガードが付いているが、上の条件のnotなのでどちらかが必ずマッチする *)
  | Black when not true -> true
  | White -> false

```

しかし、このコードをコンパイルしてみると、網羅的でない可能性があるという警告が出ます。

``` console
$ ocamlopt guard.ml ⏎
File "guard.ml", line 21, characters 21-223:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
Black
(However, some guarded clause may match this value.)
```

式の振る舞いは一般には静的に解析できないので、コンパイラは最初から解析を諦め、問答無用に警告を出すのです。
この例からも、「パターンマッチには、パターンしか書けない分、コンパイラのサポートが受けられる」という側面がわかると思います。

パターンガードには、ガード式で副作用を発生させた場合の挙動や、ORパターンと併用した場合の振る舞いなど、このほかにもいくつか注意点がありますが、ここでは深入りしないことにします。

## Void

パターンマッチのコーナーケースとして、面白い挙動があります。
パターンマッチの節を1つも書かなかったら、どうなるでしょうか。

ある意味、パターンが非網羅的なので、コンパイラから警告が出るように思えます。
しかし、これは一般には成り立たず、警告が出ずにコンパイルが通ってしまう場合があるのです。

具体的には、マッチ対象の代数的データ型のほうにもコンストラクタが1つもない場合がそのようなケースに相当します。
少しイメージしづらいかもしれませんが、Rustをはじめいくつかの言語では実際にそういうコードを書けます。
以下ではRust[^rustspec]のコードを例に、そのようなパターンマッチの挙動を見てみましょう。

> note
> Rustでは、ここまでの説明で「コンストラクタ」と呼んでいるものを「バリアント」と呼びます。
> そのため本項ではコンストラクタの代わりにバリアントという用語を使います。

[^rustspec]: 本項の内容はrust 1.37.0に基づくものです。

いま話題にしているのは以下のようなマッチ式です。

``` rust
match data {
    // マッチの節がない
}
```

本来であれば、このようなマッチ式は非網羅的なマッチとして扱われます。
Rustには例外がないので、非網羅的なマッチはそのままコンパイルエラーになります。
たとえば、`data` に整数値型の値を入れると、以下のようなエラーになります。

``` console
$ rustc void.rs ⏎
error[E0004]: non-exhaustive patterns: type `i32` is non-empty
 --> void.rs:3:11
  |
3 |     match data {};
  |           ^^^^
  |
  = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms

error: aborting due to previous error

For more information about this error, try `rustc --explain E0004`.
```

しかし、1つもバリアントがない代数的データ型が対象の場合には、このマッチは網羅的です。
Rustでは、そのような代数的データ型を以下のように定義できます。

``` rust
enum Void {}
```

この`Void`に対して先ほどの`data`を次のようにマッチさせるとコンパイルが通ります。

``` rust
fn absurd(data: Void) {
    match data {}
}
```

ここで問題になるのが、このマッチ式の返り値です。
節が1つもないので値が出てきません。
この関数を評価すると何が返ってくるでしょうか。

よく考えると、この関数はそもそも呼び出せません。
`Void`型はバリアントがないので値を作れないからです。
したがって `absurd` に渡すデータもないので、`absurd`も呼べないのです。

値がないとなると、返り値の型は何になるでしょうか。
Rustで意味のあるデータを返さない場合に使われる型はユニット型 `()` ですが、ユニット型は唯一の値として `()` （ユニット）を持ちます。
「値が返ってこない」とは意味合いが異なるので、この場合にユニット型は使えません。

実は、 `absurd` の返り値はどんな値も取りえます。
たとえば、以下のように返り値に `bool` を指定してもコンパイルが通ります。

``` rust
fn absurd(data: Void) -> bool {
    match data {}
}
```

少し奇妙に見えるかもしれませんが、これが理論的に整合した挙動です。
このような型にはパターンマッチ以外の点でも面白い話題があるのですが、本記事では立ち入らないことにします。
興味のある方は「ボトム型」などのキーワードでインターネットを検索してみてください。

空の代数的データ型は、理論的には整合していますし、実用上の便利な使い道もあるのですが、
本記事の焦点である実装という観点では少し扱いが面倒です。
たとえば、SMLでコンストラクタが1つもない代数的データ型やcase式を許すには、構文を注意深く変更しないといけないでしょう。
そもそも、「どんな型としても振る舞える型」をどう扱うかを気にする必要もあります。


理論的には整合しているので、理想的なことをいえば特別な対応は何も必要ないともいえます。
しかし、実装という観点で見ると、「節が少なくとも1つある」という情報を前提にすることで実装が楽になる場合もありえます。
そのため、節のないマッチ式も扱えるような実装では少しだけ考慮が必要になるでしょう。
